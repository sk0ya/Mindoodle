import React, { useState, useCallback } from 'react';
import { useMindMap, useKeyboardShortcuts, useMindMapStore, useMindMapPersistence } from '../../../../core';
import { findNodeById, findParentNode, getSiblingNodes, getFirstVisibleChild } from '../../../../shared/utils/nodeTreeUtils';
import ActivityBar from './ActivityBar';
import PrimarySidebar from './PrimarySidebar';
import MindMapHeader from './MindMapHeader';
import MindMapWorkspace from './MindMapWorkspace';
import MindMapModals from '../modals/MindMapModals';
import ExportModal from '../modals/ExportModal';
import ImportModal from '../modals/ImportModal';
import NodeLinkModal from '../modals/NodeLinkModal';
import LinkActionMenu from '../modals/LinkActionMenu';
import NodeNotesPanel from '../panels/NodeNotesPanel';
import OutlineWorkspace from '../outline/OutlineWorkspace';
import '../outline/OutlineWorkspace.css';
import KeyboardShortcutHelper from '../../../../shared/components/ui/KeyboardShortcutHelper';
import ContextMenu from '../../../../shared/components/ui/ContextMenu';
import { useNotification } from '../../../../shared/hooks/useNotification';
import { useErrorHandler, setupGlobalErrorHandlers } from '../../../../shared/hooks/useErrorHandler';
import { useRetryableUpload } from '../../../../shared/hooks/useRetryableUpload';
import { useAI } from '../../../../core/hooks/useAI';
import { useTheme } from '../../../../shared/hooks/useTheme';
import { useModalState } from '../../../../shared/hooks/useModalState';
import { useVimMode } from '../../../../core/hooks/useVimMode';
import MindMapProviders from './MindMapProviders';
import { logger } from '../../../../shared/utils/logger';
import VimStatusBar from '../../../../shared/components/ui/VimStatusBar';
import './MindMapApp.css';

// Types
import type { MindMapNode, FileAttachment, MindMapData, NodeLink } from '@shared/types';
import type { StorageConfig } from '../../../../core/storage/types';
// Storage configurations
const localModeConfig: StorageConfig = {
  mode: 'local'
};

const createCloudModeConfig = (authAdapter: any): StorageConfig => ({
  mode: 'cloud',
  authAdapter
});
import { useOptionalAuth, LoginModal } from '../../../../components/auth';
import { validateFile } from '../../../../shared/types/dataTypes';

// Helper function for spatial navigation fallback
const findNodeBySpatialDirection = (
  currentNodeId: string,
  direction: 'up' | 'down' | 'left' | 'right',
  rootNode: MindMapNode
): string | null => {
  const currentNode = findNodeById(rootNode, currentNodeId);
  if (!currentNode) return null;
  
  // Get all nodes in a flat list for distance calculation
  const allNodes: MindMapNode[] = [];
  const collectNodes = (node: MindMapNode) => {
    allNodes.push(node);
    if (node.children && !node.collapsed) {
      node.children.forEach(collectNodes);
    }
  };
  collectNodes(rootNode);
  
  // Filter out the current node
  const otherNodes = allNodes.filter(node => node.id !== currentNodeId);
  if (otherNodes.length === 0) return null;
  
  // Find the best node in the specified direction
  let bestNode: MindMapNode | null = null;
  let bestScore = Infinity;
  
  for (const node of otherNodes) {
    const deltaX = node.x - currentNode.x;
    const deltaY = node.y - currentNode.y;
    
    // Check if the node is in the correct direction
    let isInDirection = false;
    let directionalScore = 0;
    
    switch (direction) {
      case 'right':
        isInDirection = deltaX > 20;
        directionalScore = deltaX + Math.abs(deltaY) * 0.5;
        break;
      case 'left':
        isInDirection = deltaX < -20;
        directionalScore = -deltaX + Math.abs(deltaY) * 0.5;
        break;
      case 'down':
        isInDirection = deltaY > 20;
        directionalScore = deltaY + Math.abs(deltaX) * 0.5;
        break;
      case 'up':
        isInDirection = deltaY < -20;
        directionalScore = -deltaY + Math.abs(deltaX) * 0.5;
        break;
    }
    
    if (isInDirection && directionalScore < bestScore) {
      bestScore = directionalScore;
      bestNode = node;
    }
  }
  
  return bestNode?.id || null;
};

interface MindMapAppProps {
  storageMode?: 'local' | 'cloud';
  onModeChange?: (mode: 'local' | 'cloud') => void;
  resetKey?: number;
}

const MindMapAppContent: React.FC<MindMapAppProps> = ({ 
  storageMode = 'local', 
  onModeChange,
  resetKey = 0
}) => {
  
  const { showNotification } = useNotification();
  const { handleError, handleAsyncError } = useErrorHandler();
  const { retryableUpload, clearUploadState } = useRetryableUpload({
    maxRetries: 3,
    retryDelay: 2000, // 2Áßí
    backoffMultiplier: 1.5, // 1.5ÂÄç„Åö„Å§Â¢óÂä†
  });
  
  // Settings store for initialization
  const { loadSettingsFromStorage } = useMindMapStore();
  
  // Initialize settings on mount
  React.useEffect(() => {
    loadSettingsFromStorage();
  }, [loadSettingsFromStorage]);
  
  // Vim mode hook
  const vim = useVimMode();
  
  // VSCodeÈ¢®„Çµ„Ç§„Éâ„Éê„Éº„ÅÆÁä∂ÊÖã
  const [activeView, setActiveView] = useState<string | null>('maps');
  
  // „Ç∞„É≠„Éº„Éê„É´„Ç®„É©„Éº„Éè„É≥„Éâ„É©„Éº„ÅÆË®≠ÂÆö
  React.useEffect(() => {
    setupGlobalErrorHandlers(handleError);
  }, [handleError]);
  const [isAppReady] = useState(true);
  const [internalResetKey, setResetKey] = useState(resetKey);
  // „É¢„Éº„ÉÄ„É´Áä∂ÊÖãÁÆ°ÁêÜ
  const {
    showExportModal, setShowExportModal,
    showImportModal, setShowImportModal,
    showLoginModal, setShowLoginModal,
    showLinkModal, setShowLinkModal,
    editingLink, setEditingLink,
    linkModalNodeId, setLinkModalNodeId,
    showLinkActionMenu, setShowLinkActionMenu,
    linkActionMenuData, setLinkActionMenuData,
    contextMenu, setContextMenu
  } = useModalState();
  
  const store = useMindMapStore();
  
  // AI functionality
  const ai = useAI();
  
  // „ÉÜ„Éº„ÉûÁÆ°ÁêÜ
  useTheme();
  
  // Get auth adapter for cloud mode (using optional hook)
  const auth = useOptionalAuth();
  const authAdapter = auth?.authAdapter;
  
  // Ê∞∏Á∂öÂåñ„Éï„ÉÉ„ÇØ„ÇíÈÅ©Âàá„Å™auth adapter„Åß‰ΩøÁî®
  const persistenceHook = useMindMapPersistence({
    mode: storageMode,
    authAdapter: authAdapter // ÈÅ©Âàá„Å™auth adapter„ÇíË®≠ÂÆö
  });
  
  // For cloud mode, check if user is authenticated
  const isCloudMode = storageMode === 'cloud';
  const needsAuth = isCloudMode && auth && !auth.authState.isAuthenticated;
  
  // Show login modal when cloud mode requires auth
  React.useEffect(() => {
    logger.debug('Auth check:', {
      isCloudMode,
      hasAuth: !!auth,
      authIsReady: auth?.isReady,
      isAuthenticated: auth?.authState.isAuthenticated,
      needsAuth,
      showLoginModal
    });

    if (needsAuth && auth?.isReady) {
      logger.info('Showing login modal');
      setShowLoginModal(true);
    } else if (isCloudMode && auth?.authState.isAuthenticated) {
      logger.info('User authenticated, hiding login modal');
      setShowLoginModal(false);
    }
  }, [needsAuth, auth?.isReady, auth?.authState.isAuthenticated, isCloudMode, showLoginModal, auth, setShowLoginModal]);

  // Force data reload when authentication status changes in cloud mode
  React.useEffect(() => {
    if (isCloudMode && auth?.authState.isAuthenticated && auth?.isReady) {
      logger.info('üîÑ Authentication successful in cloud mode, forcing data reload');
      // Increment reset key to force useMindMap to reinitialize with new auth context
      setResetKey(prev => prev + 1);
    }
  }, [isCloudMode, auth?.authState.isAuthenticated, auth?.isReady]);

  // Sync external resetKey with internal resetKey
  React.useEffect(() => {
    setResetKey(resetKey);
  }, [resetKey]);

  // Handle mode changes - reset modal state when switching to cloud mode
  React.useEffect(() => {
    if (isCloudMode && auth && !auth.authState.isAuthenticated && auth.isReady) {
      logger.info('Mode switched to cloud, user not authenticated');
      setShowLoginModal(true);
    } else if (!isCloudMode) {
      logger.info('Mode switched to local, hiding login modal');
      setShowLoginModal(false);
    }
  }, [storageMode, isCloudMode, auth?.authState.isAuthenticated, auth?.isReady, auth, setShowLoginModal]);
  
  // Create storage configuration based on selected mode
  const storageConfig: StorageConfig = React.useMemo(() => {
    
    let config: StorageConfig;
    switch (storageMode) {
      case 'local':
        config = localModeConfig;
        break;
      case 'cloud':
        if (authAdapter) {
          config = createCloudModeConfig(authAdapter);
        } else {
          // Auth adapter not available, fall back to local mode
          logger.warn('Cloud mode requested but auth adapter not available, falling back to local mode');
          config = localModeConfig;
        }
        break;
      default:
        config = localModeConfig;
        break;
    }
    
    
    return config;
  }, [storageMode, authAdapter]);
  
  // „É™„Çª„ÉÉ„Éà„Ç≠„Éº„ÅßuseMindMap„ÇíÂº∑Âà∂„É™„Çª„ÉÉ„Éà
  const mindMap = useMindMap(isAppReady, storageConfig, Math.max(resetKey, internalResetKey));
  const { 
    data, 
    selectedNodeId, 
    editingNodeId, 
    editText, 
    ui, 
    canUndo, 
    canRedo, 
    allMindMaps, 
    currentMapId,
    
    // Áµ±Âêà„Åï„Çå„Åü„Éè„É≥„Éâ„É©„Éº
    addNode,
    updateNode, 
    deleteNode,
    moveNode,
    selectNode,
    startEditing,
    startEditingWithCursorAtEnd,
    startEditingWithCursorAtStart,
    finishEditing,
    
    // UIÊìç‰Ωú
    showImageModal,
    showFileActionMenu,
    closeAllPanels,
    setZoom,
    setPan,
    setEditText,
    changeSiblingOrder,
    toggleNodeCollapse,
    
    // „Éû„ÉÉ„ÉóÊìç‰Ωú
    createAndSelectMap,
    selectMapById,
    deleteMap,
    updateMapMetadata,
    addImportedMapToList,
    applyAutoLayout,
    
    // Â±•Ê≠¥Êìç‰Ωú
    undo,
    redo
  } = mindMap;

  // „Éï„Ç©„É´„ÉÄÁßªÂãïÁî®„ÅÆ‰∏ÄÊã¨„Ç´„ÉÜ„Ç¥„É™Êõ¥Êñ∞Èñ¢Êï∞
  const updateMultipleMapCategories = React.useCallback(async (mapUpdates: Array<{id: string, category: string}>) => {
    console.log('Updating multiple map categories:', mapUpdates);
    
    if (mapUpdates.length === 0) return;
    
    try {
      // ‰∏ÄÊã¨„Åß„Éû„ÉÉ„ÉóÊÉÖÂ†±„ÇíÊõ¥Êñ∞
      const updatedMaps = mapUpdates.map(update => {
        const mapToUpdate = allMindMaps.find(map => map.id === update.id);
        if (!mapToUpdate) return null;
        
        return {
          ...mapToUpdate,
          category: update.category,
          updatedAt: new Date().toISOString()
        };
      }).filter(Boolean);
      
      console.log(`Batch updating ${updatedMaps.length} maps`);
      
      // ÂêÑ„Éû„ÉÉ„Éó„Çí‰∏¶ÂàóÊõ¥Êñ∞ÔºàÈùûÂêåÊúüÂá¶ÁêÜ„Çí‰∏¶ÂàóÂÆüË°åÔºâ
      await Promise.all(
        updatedMaps.map(async (updatedMap) => {
          if (updatedMap) {
            console.log(`Updating map "${updatedMap.title}" to "${updatedMap.category}"`);
            await persistenceHook.updateMapInList(updatedMap);
          }
        })
      );
      
      // ÊàêÂäüÂæå„Å´„Éû„ÉÉ„Éó„É™„Çπ„Éà„ÇíÂº∑Âà∂Êõ¥Êñ∞„Åó„Å¶UI„ÇíÂç≥Â∫ß„Å´ÂèçÊò†
      await persistenceHook.refreshMapList();
      
      console.log(`Successfully batch updated ${updatedMaps.length} maps`);
    } catch (error) {
      console.error('Failed to batch update map categories:', error);
      // „Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„ÅüÂ†¥Âêà„ÇÇ„ÄÅÂèØËÉΩ„Å™Èôê„ÇäÁä∂ÊÖã„ÇíÂêåÊúü
      await persistenceHook.refreshMapList();
    }
  }, [allMindMaps, persistenceHook]);

  // „Ç≠„Éº„Éú„Éº„Éâ„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„ÉàË®≠ÂÆö
  useKeyboardShortcuts({
    selectedNodeId,
    editingNodeId,
    setEditText,
    startEdit: startEditing,
    startEditWithCursorAtEnd: startEditingWithCursorAtEnd,
    startEditWithCursorAtStart: startEditingWithCursorAtStart,
    finishEdit: async (nodeId: string, text?: string) => {
      if (text !== undefined) {
        finishEditing(nodeId, text);
      }
    },
    editText,
    updateNode,
    addChildNode: async (parentId: string, text?: string, autoEdit?: boolean) => {
      try {
        const newNodeId = store.addChildNode(parentId, text);
        if (autoEdit && newNodeId) {
          // Á∑®ÈõÜ„É¢„Éº„Éâ„ÇíÈñãÂßã„Åô„ÇãÂâç„Å´„ÄÅÂ∞ë„ÅóÂæÖÊ©ü„Åó„Å¶DOM„ÅåÊõ¥Êñ∞„Åï„Çå„Çã„ÅÆ„ÇíÂæÖ„Å§
          setTimeout(() => {
            startEditing(newNodeId);
          }, 50);
        }
        return newNodeId || null;
      } catch (error) {
        logger.error('Â≠ê„Éé„Éº„ÉâËøΩÂä†„Å´Â§±Êïó:', error);
        return null;
      }
    },
    addSiblingNode: async (nodeId: string, text?: string, autoEdit?: boolean) => {
      try {
        const newNodeId = store.addSiblingNode(nodeId, text);
        if (autoEdit && newNodeId) {
          // Á∑®ÈõÜ„É¢„Éº„Éâ„ÇíÈñãÂßã„Åô„ÇãÂâç„Å´„ÄÅÂ∞ë„ÅóÂæÖÊ©ü„Åó„Å¶DOM„ÅåÊõ¥Êñ∞„Åï„Çå„Çã„ÅÆ„ÇíÂæÖ„Å§
          setTimeout(() => {
            startEditing(newNodeId);
          }, 50);
        }
        return newNodeId || null;
      } catch (error) {
        logger.error('ÂÖÑÂºü„Éé„Éº„ÉâËøΩÂä†„Å´Â§±Êïó:', error);
        return null;
      }
    },
    deleteNode,
    undo,
    redo,
    canUndo,
    canRedo,
    navigateToDirection: (direction: 'up' | 'down' | 'left' | 'right') => {
      if (!selectedNodeId || !data?.rootNode) return;
      
      const currentNode = findNodeById(data.rootNode, selectedNodeId);
      if (!currentNode) return;
      
      let nextNodeId: string | null = null;
      
      switch (direction) {
        case 'left': // h - Move to parent node
          const parent = findParentNode(data.rootNode, selectedNodeId);
          if (parent) {
            nextNodeId = parent.id;
          }
          break;
          
        case 'right': // l - Move to first child (expand if collapsed)
          const firstChild = getFirstVisibleChild(currentNode);
          if (firstChild) {
            nextNodeId = firstChild.id;
          } else if (currentNode.children && currentNode.children.length > 0 && currentNode.collapsed) {
            // Expand collapsed node and move to first child
            updateNode(selectedNodeId, { collapsed: false });
            nextNodeId = currentNode.children[0].id;
          }
          break;
          
        case 'up': // k - Move to previous sibling
        case 'down': // j - Move to next sibling
          const { siblings, currentIndex } = getSiblingNodes(data.rootNode, selectedNodeId);
          if (siblings.length > 1 && currentIndex !== -1) {
            let targetIndex = -1;
            if (direction === 'up' && currentIndex > 0) {
              targetIndex = currentIndex - 1;
            } else if (direction === 'down' && currentIndex < siblings.length - 1) {
              targetIndex = currentIndex + 1;
            }
            if (targetIndex !== -1) {
              nextNodeId = siblings[targetIndex].id;
            }
          }
          break;
      }
      
      // Fallback to spatial navigation if hierarchical navigation doesn't work
      if (!nextNodeId) {
        nextNodeId = findNodeBySpatialDirection(selectedNodeId, direction, data.rootNode);
      }
      
      if (nextNodeId) {
        selectNode(nextNodeId);
      }
    },
    showMapList: ui.showMapList,
    setShowMapList: (show: boolean) => store.setShowMapList(show),
    showLocalStorage: ui.showLocalStoragePanel,
    setShowLocalStorage: (show: boolean) => store.setShowLocalStoragePanel(show),
    showTutorial: ui.showTutorial,
    setShowTutorial: (show: boolean) => store.setShowTutorial(show),
    showKeyboardHelper: ui.showShortcutHelper,
    setShowKeyboardHelper: (show: boolean) => store.setShowShortcutHelper(show),
    copyNode: (nodeId: string) => {
      const node = data?.rootNode ? findNodeById(data.rootNode, nodeId) : null;
      if (node) {
        // ÂÜÖÈÉ®„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Å´‰øùÂ≠ò
        store.setClipboard(node);
        
        // „Ç∑„Çπ„ÉÜ„É†„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Å´„Éû„Éº„ÇØ„ÉÄ„Ç¶„É≥ÂΩ¢Âºè„Åß‰øùÂ≠ò
        const convertNodeToMarkdown = (node: MindMapNode, level: number = 0): string => {
          const prefix = '#'.repeat(Math.min(level + 1, 6)) + ' ';
          let markdown = `${prefix}${node.text}\n`;
          
          // „Éé„Éº„Éà„Åå„ÅÇ„Çå„Å∞ËøΩÂä†
          if (node.note && node.note.trim()) {
            markdown += `${node.note}\n`;
          }
          
          // Â≠ê„Éé„Éº„Éâ„ÇíÂÜçÂ∏∞ÁöÑ„Å´Âá¶ÁêÜ
          if (node.children && node.children.length > 0) {
            node.children.forEach(child => {
              markdown += convertNodeToMarkdown(child, level + 1);
            });
          }
          
          return markdown;
        };
        
        const markdownText = convertNodeToMarkdown(node);
        
        // „Ç∑„Çπ„ÉÜ„É†„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Å´Êõ∏„ÅçËæº„Åø
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(markdownText).catch((error) => {
            console.warn('„Ç∑„Çπ„ÉÜ„É†„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Å∏„ÅÆÊõ∏„ÅçËæº„Åø„Å´Â§±Êïó:', error);
          });
        }
        
        showNotification('success', `„Äå${node.text}„Äç„Çí„Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü`);
      }
    },
    pasteNode: async (parentId: string) => {
      // „Åæ„Åö„Ç∑„Çπ„ÉÜ„É†„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Åã„ÇâMindMeister„ÅÆ„Éû„Éº„ÇØ„ÉÄ„Ç¶„É≥„ÇíÁ¢∫Ë™ç
      try {
        if (navigator.clipboard && navigator.clipboard.readText) {
          const clipboardText = await navigator.clipboard.readText();
          
          // MindMeister„ÅÆ„Éû„Éº„ÇØ„ÉÄ„Ç¶„É≥ÂΩ¢Âºè„Åã„ÉÅ„Çß„ÉÉ„ÇØ
          const { isMindMeisterFormat, parseMindMeisterMarkdown } = await import('../../../../shared/utils/mindMeisterParser');
          
          if (clipboardText && isMindMeisterFormat(clipboardText)) {
            const parsedNode = parseMindMeisterMarkdown(clipboardText);
            
            if (parsedNode) {
              // „Éë„Éº„Çπ„Åï„Çå„Åü„Éé„Éº„ÉâÊßãÈÄ†„ÇíË≤º„Çä‰ªò„Åë
              const pasteNodeRecursively = (nodeToAdd: MindMapNode, parentId: string): string | undefined => {
                const newNodeId = store.addChildNode(parentId, nodeToAdd.text);
                
                if (newNodeId) {
                  updateNode(newNodeId, {
                    fontSize: nodeToAdd.fontSize,
                    fontWeight: nodeToAdd.fontWeight,
                    color: nodeToAdd.color,
                    collapsed: false,
                    attachments: nodeToAdd.attachments || [],
                    note: nodeToAdd.note
                  });
                  
                  if (nodeToAdd.children && nodeToAdd.children.length > 0) {
                    nodeToAdd.children.forEach(child => {
                      pasteNodeRecursively(child, newNodeId);
                    });
                  }
                }
                
                return newNodeId;
              };
              
              const newNodeId = pasteNodeRecursively(parsedNode, parentId);
              if (newNodeId) {
                showNotification('success', `„Äå${parsedNode.text}„Äç„ÇíMindMeister„Åã„ÇâË≤º„Çä‰ªò„Åë„Åæ„Åó„Åü`);
                selectNode(newNodeId);
                return;
              }
            }
          }
        }
      } catch (error) {
        console.warn('„Ç∑„Çπ„ÉÜ„É†„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Åã„Çâ„ÅÆË™≠„ÅøÂèñ„Çä„Å´Â§±Êïó:', error);
      }
      
      // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: ÂÜÖÈÉ®„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Åã„ÇâË≤º„Çä‰ªò„Åë
      const clipboardNode = ui.clipboard;
      if (!clipboardNode) {
        showNotification('warning', '„Ç≥„Éî„Éº„Åï„Çå„Åü„Éé„Éº„Éâ„Åå„ÅÇ„Çä„Åæ„Åõ„Çì');
        return;
      }
      
      const pasteNodeRecursively = (nodeToAdd: MindMapNode, parentId: string): string | undefined => {
        const newNodeId = store.addChildNode(parentId, nodeToAdd.text);
        
        if (newNodeId) {
          updateNode(newNodeId, {
            fontSize: nodeToAdd.fontSize,
            fontWeight: nodeToAdd.fontWeight,
            color: nodeToAdd.color,
            collapsed: false,
            attachments: nodeToAdd.attachments || []
          });
          
          if (nodeToAdd.children && nodeToAdd.children.length > 0) {
            nodeToAdd.children.forEach(child => {
              pasteNodeRecursively(child, newNodeId);
            });
          }
        }
        
        return newNodeId;
      };
      
      const newNodeId = pasteNodeRecursively(clipboardNode, parentId);
      if (newNodeId) {
        showNotification('success', `„Äå${clipboardNode.text}„Äç„ÇíË≤º„Çä‰ªò„Åë„Åæ„Åó„Åü`);
        selectNode(newNodeId);
      }
    },
    pasteImageFromClipboard: async (nodeId: string) => {
      try {
        // „Ç∑„Çπ„ÉÜ„É†„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Ç¢„ÇØ„Çª„Çπ„ÅÆÊ®©ÈôêÁ¢∫Ë™ç
        if (!navigator.clipboard || !navigator.clipboard.read) {
          throw new Error('„ÇØ„É™„ÉÉ„Éó„Éú„Éº„ÉâAPI„ÅåÂà©Áî®„Åß„Åç„Åæ„Åõ„Çì');
        }

        const clipboardItems = await navigator.clipboard.read();
        let imageFound = false;

        for (const clipboardItem of clipboardItems) {
          for (const type of clipboardItem.types) {
            if (type.startsWith('image/')) {
              imageFound = true;
              const blob = await clipboardItem.getType(type);
              
              // Blob „Çí File „Å´Â§âÊèõ
              const timestamp = Date.now();
              const extension = type.split('/')[1] || 'png';
              const fileName = `pasted-image-${timestamp}.${extension}`;
              const file = new File([blob], fileName, { type });

              // Êó¢Â≠ò„ÅÆ„Éï„Ç°„Ç§„É´„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÂá¶ÁêÜ„Çí‰ΩøÁî®
              await handleFileUpload(nodeId, file);
              showNotification('success', 'ÁîªÂÉè„ÇíË≤º„Çä‰ªò„Åë„Åæ„Åó„Åü');
              return;
            }
          }
        }

        if (!imageFound) {
          throw new Error('„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Å´ÁîªÂÉè„Åå„ÅÇ„Çä„Åæ„Åõ„Çì');
        }
      } catch (error) {
        // „Ç®„É©„Éº„ÅØ‰∏ä‰Ωç„Åß„Ç≠„É£„ÉÉ„ÉÅ„Åï„Çå„Å¶ÈÄöÂ∏∏„ÅÆ„Éö„Éº„Çπ„Éà„Å´„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ
        throw error;
      }
    },
    findNodeById: (nodeId: string) => data?.rootNode ? findNodeById(data.rootNode, nodeId) : null,
    closeAttachmentAndLinkLists: store.closeAttachmentAndLinkLists,
    cancelEditing: store.cancelEditing
  }, vim);

  // UI state „Åã„ÇâÂÄãÂà•„Å´ÂèñÂæó
  const { showKeyboardHelper, setShowKeyboardHelper } = {
    showKeyboardHelper: ui.showShortcutHelper,
    setShowKeyboardHelper: (show: boolean) => store.setShowShortcutHelper(show)
  };

  // „Éï„Ç°„Ç§„É´„Éè„É≥„Éâ„É©„ÉºÔºà„ÇØ„É©„Ç¶„ÉâÂØæÂøúÔºâ
  const handleFileUpload = async (nodeId: string, file: File): Promise<void> => {
    if (!data) {
      handleError(new Error('„Éû„Ç§„É≥„Éâ„Éû„ÉÉ„Éó„Éá„Éº„Çø„ÅåÂà©Áî®„Åß„Åç„Åæ„Åõ„Çì'), '„Éï„Ç°„Ç§„É´„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ', '„Éá„Éº„Çø„ÉÅ„Çß„ÉÉ„ÇØ');
      return;
    }

    // „Éï„Ç°„Ç§„É´„Éê„É™„Éá„Éº„Ç∑„Éß„É≥
    const validationErrors = validateFile(file);
    if (validationErrors.length > 0) {
      validationErrors.forEach((error: string) => showNotification('error', error));
      return;
    }

    const uploadKey = `${nodeId}_${file.name}_${Date.now()}`;
    
    try {
      await handleAsyncError((async () => {
        const fileAttachment = await retryableUpload(
          uploadKey,
          file.name,
          async (): Promise<FileAttachment> => {
            if (storageMode === 'cloud') {
              // „ÇØ„É©„Ç¶„Éâ„É¢„Éº„Éâ: API„Å´„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Åó„Å¶Cloudflare„Å´‰øùÂ≠ò
              logger.info('Uploading file to cloud storage...', { 
                fileName: file.name, 
                fileSize: file.size, 
                fileType: file.type,
                nodeId,
                mapId: data.id
              });
              
              // CloudStorageAdapter„ÇíÁõ¥Êé•‰ΩøÁî®
              const { CloudStorageAdapter } = await import('../../../../core/storage/adapters/CloudStorageAdapter');
              logger.debug('CloudStorageAdapter imported successfully');
              
              if (!auth) {
                logger.error('Authentication not available for cloud upload');
                throw new Error('„ÇØ„É©„Ç¶„Éâ„Éï„Ç°„Ç§„É´„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Å´„ÅØË™çË®º„ÅåÂøÖË¶Å„Åß„Åô');
              }
              
              logger.info('üöÄ Cloud mode file upload starting...', {
                fileName: file.name,
                fileSize: file.size,
                fileType: file.type,
                nodeId: nodeId,
                mapId: data?.id,
                hasAuth: !!auth,
                hasAuthAdapter: !!auth.authAdapter,
                isAuthenticated: auth.authAdapter?.isAuthenticated,
                userId: auth.authAdapter?.user?.id
              });
              
              const storageAdapter = new CloudStorageAdapter(auth.authAdapter);
              logger.debug('CloudStorageAdapter created, initializing...');
              
              await storageAdapter.initialize();
              logger.debug('CloudStorageAdapter initialized');
              
              if (typeof storageAdapter.uploadFile === 'function') {
                logger.debug('Calling uploadFile method...');
                const uploadResult = await storageAdapter.uploadFile(data.id, nodeId, file);
                logger.debug('Upload result received:', uploadResult);
                
                const fileAttachment = {
                  id: uploadResult.id,
                  name: uploadResult.fileName,
                  type: uploadResult.mimeType,
                  size: uploadResult.fileSize,
                  isImage: uploadResult.attachmentType === 'image',
                  createdAt: uploadResult.uploadedAt,
                  downloadUrl: uploadResult.downloadUrl,
                  storagePath: uploadResult.storagePath,
                  r2FileId: uploadResult.id,
                  nodeId: nodeId // nodeId„ÇÇ‰øùÂ≠ò
                };
                logger.info('File uploaded to cloud successfully:', fileAttachment);
                logger.info('Upload result details:', {
                  uploadResultId: uploadResult.id,
                  fileName: uploadResult.fileName,
                  mapId: data.id,
                  nodeId: nodeId,
                  fullUploadResult: uploadResult
                });
                return fileAttachment;
              } else {
                logger.error('uploadFile method not available on storage adapter');
                throw new Error('Cloud storage adapter not available or uploadFile method missing');
              }
            } else {
              // „É≠„Éº„Ç´„É´„É¢„Éº„Éâ: Base64„Ç®„É≥„Ç≥„Éº„Éâ„Åó„Å¶„É≠„Éº„Ç´„É´‰øùÂ≠ò
              logger.debug('Processing file for local storage...');
              
              const reader = new FileReader();
              const dataURL = await new Promise<string>((resolve, reject) => {
                reader.onload = () => resolve(reader.result as string);
                reader.onerror = reject;
                reader.readAsDataURL(file);
              });

              const fileAttachment = {
                id: `file_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                name: file.name,
                type: file.type,
                size: file.size,
                isImage: file.type.startsWith('image/'),
                createdAt: new Date().toISOString(),
                dataURL: dataURL,
                data: dataURL.split(',')[1] // Base64 part only
              };
              logger.debug('File processed for local storage:', fileAttachment.name);
              return fileAttachment;
            }
          }
        );
        
        // „Éé„Éº„Éâ„Å´„Éï„Ç°„Ç§„É´„ÇíÊ∑ª‰ªò
        const node = data?.rootNode && findNodeById(data.rootNode, nodeId);
        if (node) {
          logger.info('üìé Attaching file to node...', {
            nodeId,
            fileName: fileAttachment.name,
            hasDownloadUrl: !!fileAttachment.downloadUrl,
            hasDataURL: !!fileAttachment.dataURL,
            downloadUrl: fileAttachment.downloadUrl ? fileAttachment.downloadUrl.substring(0, 100) + '...' : 'none',
            existingAttachments: node.attachments?.length || 0
          });
          
          const updatedNode = {
            ...node,
            attachments: [...(node.attachments || []), fileAttachment]
          };
          updateNode(nodeId, updatedNode);
          logger.info('‚úÖ File attached to node successfully:', {
            nodeId,
            fileName: fileAttachment.name,
            totalAttachments: updatedNode.attachments.length
          });
          
          // „Éï„Ç°„Ç§„É´Ê∑ª‰ªòÂæå„Å´Ëá™ÂãïÊï¥Âàó„ÇíÂÆüË°å
          if (typeof applyAutoLayout === 'function') {
            logger.debug('üéØ Applying auto layout after file attachment');
            requestAnimationFrame(() => {
              applyAutoLayout();
            });
          }
        } else {
          throw new Error(`„Éé„Éº„Éâ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì: ${nodeId}`);
        }
      })(), '„Éï„Ç°„Ç§„É´„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ', `${file.name}„ÅÆ„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ`);
      
      // ÊàêÂäüÊôÇ„ÅØËá™ÂãïÂâäÈô§„Å´‰ªª„Åõ„ÇãÔºàuseFileUpload„Åß1ÁßíÂæå„Å´ÂâäÈô§„Åï„Çå„ÇãÔºâ
      logger.debug('Upload completed successfully, waiting for auto-cleanup');
    } catch (error) {
      // „Ç®„É©„ÉºÊôÇ„ÅÆ„ÅøÂç≥Â∫ß„Å´„ÇØ„É™„Ç¢
      clearUploadState(uploadKey);
      logger.debug('Upload state cleared due to error:', uploadKey);
      throw error;
    }
  };

  // „Éï„Ç°„Ç§„É´„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Éè„É≥„Éâ„É©„Éº
  const handleFileDownload = async (file: FileAttachment): Promise<void> => {
    try {
      let downloadUrl: string;
      const fileName = file.name;

      if (storageMode === 'cloud' && (file.r2FileId || file.id)) {
        // „ÇØ„É©„Ç¶„Éâ„É¢„Éº„Éâ: API„Çí‰ΩøÁî®„Åó„Å¶„Éï„Ç°„Ç§„É´„Çí„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ
        const fileId = file.r2FileId || file.id; // Âè§„ÅÑ„Éï„Ç°„Ç§„É´„Å®„ÅÆ‰∫íÊèõÊÄß
        logger.info('Downloading file from cloud storage...', { 
          fileName: file.name, 
          fileId: fileId,
          r2FileId: file.r2FileId,
          originalId: file.id,
          nodeId: file.nodeId,
          mapId: data?.id,
          fullFile: file
        });

        if (!data) {
          throw new Error('„Éû„Ç§„É≥„Éâ„Éû„ÉÉ„Éó„Éá„Éº„Çø„ÅåÂà©Áî®„Åß„Åç„Åæ„Åõ„Çì');
        }

        if (!auth || !auth.authAdapter) {
          throw new Error('„ÇØ„É©„Ç¶„Éâ„Éï„Ç°„Ç§„É´„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Å´„ÅØË™çË®º„ÅåÂøÖË¶Å„Åß„Åô');
        }

        // CloudStorageAdapter„ÇíÁõ¥Êé•‰ΩøÁî®„Åó„Å¶„Éï„Ç°„Ç§„É´„Çí„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ
        const { CloudStorageAdapter } = await import('../../../../core/storage/adapters/CloudStorageAdapter');
        const storageAdapter = new CloudStorageAdapter(auth.authAdapter);
        
        await storageAdapter.initialize();
        
        if (typeof storageAdapter.downloadFile === 'function') {
          logger.debug('Calling downloadFile method...');
          const blob = await storageAdapter.downloadFile(data.id, file.nodeId || '', fileId);
          logger.debug('Download blob received:', { size: blob.size, type: blob.type });
          
          // Blob„Åã„Çâ„ÉÄ„Ç¶„É≥„É≠„Éº„ÉâURL„Çí‰ΩúÊàê
          downloadUrl = URL.createObjectURL(blob);
          logger.info('File downloaded from cloud successfully');
        } else {
          logger.error('downloadFile method not available on storage adapter');
          throw new Error('Cloud storage adapter downloadFile method not available');
        }
      } else if (file.data) {
        // „É≠„Éº„Ç´„É´„É¢„Éº„Éâ: Base64„Éá„Éº„Çø„Åã„ÇâÁõ¥Êé•‰ΩøÁî®
        downloadUrl = `data:${file.type};base64,${file.data}`;
      } else if (file.dataURL) {
        // ÂæåÊñπ‰∫íÊèõÊÄß: dataURL„Çí‰ΩøÁî®
        downloadUrl = file.dataURL;
      } else if (storageMode === 'cloud' && file.downloadUrl) {
        // Âè§„ÅÑ„ÇØ„É©„Ç¶„Éâ„Éï„Ç°„Ç§„É´: downloadUrl„ÇíÁõ¥Êé•‰ΩøÁî®ÔºàË™çË®º„Å™„Åó„ÄÅÂè§„ÅÑÂΩ¢ÂºèÔºâ
        logger.info('Using legacy downloadUrl for old cloud file');
        downloadUrl = file.downloadUrl;
      } else {
        logger.error('No download data found in file:', file);
        throw new Error('„ÉÄ„Ç¶„É≥„É≠„Éº„ÉâÂèØËÉΩ„Å™„Éï„Ç°„Ç§„É´„Éá„Éº„Çø„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
      }

      // „ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„ÇíÂÆüË°å
      const link = document.createElement('a');
      link.href = downloadUrl;
      link.download = fileName;
      link.style.display = 'none';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);

      // BlobURL„Çí‰ΩøÁî®„Åó„ÅüÂ†¥Âêà„ÅØ„É°„É¢„É™„ÇíËß£Êîæ
      if (downloadUrl.startsWith('blob:')) {
        setTimeout(() => URL.revokeObjectURL(downloadUrl), 100);
      }

      logger.info('File download completed successfully:', fileName);
    } catch (error) {
      logger.error('File download failed:', error);
      showNotification('error', `${file.name} „ÅÆ„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü`);
      handleError(error as Error, '„Éï„Ç°„Ç§„É´„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ', file.name);
    }
  };

  // „Éï„Ç°„Ç§„É´ÂâäÈô§„Éè„É≥„Éâ„É©„Éº
  const handleFileDelete = async (nodeId: string, fileId: string): Promise<void> => {
    try {
      if (!data) {
        throw new Error('„Éû„Ç§„É≥„Éâ„Éû„ÉÉ„Éó„Éá„Éº„Çø„ÅåÂà©Áî®„Åß„Åç„Åæ„Åõ„Çì');
      }

      const node = findNodeById(data.rootNode, nodeId);
      if (!node || !node.attachments) {
        throw new Error('„Éé„Éº„Éâ„Åæ„Åü„ÅØÊ∑ª‰ªò„Éï„Ç°„Ç§„É´„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
      }

      const fileToDelete = node.attachments.find(file => file.id === fileId);
      if (!fileToDelete) {
        throw new Error('ÂâäÈô§„Åô„Çã„Éï„Ç°„Ç§„É´„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
      }

      // „ÇØ„É©„Ç¶„Éâ„É¢„Éº„Éâ„ÅÆÂ†¥Âêà„ÅØ„Çµ„Éº„Éê„Éº„Åã„Çâ„ÇÇÂâäÈô§
      if (storageMode === 'cloud' && (fileToDelete.r2FileId || fileToDelete.id)) {
        const fileIdForDeletion = fileToDelete.r2FileId || fileToDelete.id;
        logger.info('Deleting file from cloud storage...', { 
          fileName: fileToDelete.name, 
          fileId: fileIdForDeletion,
          nodeId: nodeId,
          mapId: data.id
        });

        // „Çπ„Éà„É¨„Éº„Ç∏„Ç¢„ÉÄ„Éó„Çø„Éº„ÇíÁõ¥Êé•‰ΩúÊàê
        const { createStorageAdapter } = await import('../../../../core/storage/StorageAdapterFactory');
        const adapter = await createStorageAdapter(storageConfig);
        if (adapter && 'deleteFile' in adapter && typeof adapter.deleteFile === 'function') {
          await adapter.deleteFile(data.id, nodeId, fileIdForDeletion);
          logger.info('File deleted from cloud storage successfully');
        }
      }

      // „Éé„Éº„Éâ„Åã„ÇâÊ∑ª‰ªò„Éï„Ç°„Ç§„É´„ÇíÂâäÈô§
      const updatedAttachments = node.attachments.filter(file => file.id !== fileId);
      const updatedNode = {
        ...node,
        attachments: updatedAttachments
      };

      updateNode(nodeId, updatedNode);
      showNotification('success', `${fileToDelete.name} „ÇíÂâäÈô§„Åó„Åæ„Åó„Åü`);
      logger.debug('File deleted from node:', { nodeId, fileId, fileName: fileToDelete.name });
    } catch (error) {
      logger.error('File delete failed:', error);
      showNotification('error', '„Éï„Ç°„Ç§„É´„ÅÆÂâäÈô§„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
      handleError(error as Error, '„Éï„Ç°„Ç§„É´ÂâäÈô§', fileId);
    }
  };

  // „É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£Èñ¢Êï∞

  // Context menu handlers
  const handleRightClick = (e: React.MouseEvent, nodeId: string) => {
    e.preventDefault();
    
    // „É™„É≥„ÇØ„É™„Çπ„Éà„Åæ„Åü„ÅØÊ∑ª‰ªò„Éï„Ç°„Ç§„É´„É™„Çπ„ÉàË°®Á§∫‰∏≠„ÅØÂè≥„ÇØ„É™„ÉÉ„ÇØ„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„É°„Éã„É•„Éº„ÇíÁÑ°ÂäπÂåñ
    if (ui.showLinkListForNode || ui.showAttachmentListForNode) {
      return;
    }
    
    setContextMenu({
      visible: true,
      position: { x: e.clientX, y: e.clientY },
      nodeId: nodeId
    });
    selectNode(nodeId); // Select the node when right-clicking
  };

  const handleContextMenuClose = () => {
    setContextMenu({
      visible: false,
      position: { x: 0, y: 0 },
      nodeId: null
    });
  };

  const handleAIGenerate = async (node: MindMapNode) => {
    // ÁîüÊàêÈñãÂßã„ÅÆÈÄöÁü•
    showNotification('info', 'AIÂ≠ê„Éé„Éº„ÉâÁîüÊàê‰∏≠... ü§ñ');
    
    try {
      const childTexts = await ai.generateChildNodes(node);
      
      // Generate child nodes based on AI suggestions
      childTexts.forEach(text => {
        addNode(node.id, text.trim());
      });
      
      showNotification('success', `‚úÖ ${childTexts.length}ÂÄã„ÅÆÂ≠ê„Éé„Éº„Éâ„ÇíÁîüÊàê„Åó„Åæ„Åó„Åü`);
    } catch (error) {
      logger.error('AI child node generation failed:', error);
      showNotification('error', '‚ùå AIÂ≠ê„Éé„Éº„ÉâÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
    } finally {
      handleContextMenuClose();
    }
  };

  // ‰ªñ„ÅÆ„Éû„ÉÉ„Éó„ÅÆ„Éá„Éº„Çø„ÇíÂèñÂæó„Åô„ÇãÈñ¢Êï∞
  const loadMapData = useCallback(async (mapId: string): Promise<MindMapData | null> => {
    try {
      if (data && mapId === data.id) {
        // ÁèæÂú®„ÅÆ„Éû„ÉÉ„Éó„ÅÆÂ†¥Âêà„ÅØ„Åù„ÅÆ„Åæ„ÅæËøî„Åô
        return data;
      }
      
      // ‰ªñ„ÅÆ„Éû„ÉÉ„Éó„ÅÆ„Éá„Éº„Çø„ÇíË™≠„ÅøËæº„ÇÄ
      // Ê∞∏Á∂öÂåñ„Éï„ÉÉ„ÇØ„Åã„ÇâÈÅ©Âàá„Å™„É°„ÇΩ„ÉÉ„Éâ„Çí‰ΩøÁî®
      const targetMap = allMindMaps.find(map => map.id === mapId);
      if (targetMap) {
        // Êó¢„Å´Ë™≠„ÅøËæº„ÅøÊ∏à„Åø„ÅÆ„Éû„ÉÉ„Éó„Éá„Éº„Çø„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØ„Åù„Çå„ÇíËøî„Åô
        return targetMap;
      }
      
      // „Éû„ÉÉ„Éó„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑÂ†¥Âêà
      logger.warn('ÊåáÂÆö„Åï„Çå„Åü„Éû„ÉÉ„Éó„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì:', mapId);
      showNotification('warning', 'ÊåáÂÆö„Åï„Çå„Åü„Éû„ÉÉ„Éó„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
      return null;
    } catch (error) {
      logger.error('„Éû„ÉÉ„Éó„Éá„Éº„Çø„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó:', error);
      showNotification('error', '„Éû„ÉÉ„Éó„Éá„Éº„Çø„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
      return null;
    }
  }, [data, allMindMaps, showNotification]);

  // UIÁî®„ÅÆ„Éè„É≥„Éâ„É©„Éº
  const handleTitleChange = (title: string) => {
    if (data) {
      updateMapMetadata(data.id, { title });
    }
  };

  // „Ç®„ÇØ„Çπ„Éù„Éº„Éà„Éè„É≥„Éâ„É©„Éº
  const handleExport = () => {
    setShowExportModal(true);
  };

  // „Éû„Éº„ÇØ„ÉÄ„Ç¶„É≥„Ç§„É≥„Éù„Éº„Éà„Éè„É≥„Éâ„É©„Éº
  const handleImport = () => {
    setShowImportModal(true);
  };

  // „Ç§„É≥„Éù„Éº„ÉàÊàêÂäüÊôÇ„ÅÆ„Éè„É≥„Éâ„É©„Éº
  const handleImportSuccess = async (importedData: MindMapData, warnings?: string[]) => {
    try {
      logger.info('„Éû„Éº„ÇØ„ÉÄ„Ç¶„É≥„Ç§„É≥„Éù„Éº„Éà„ÅåÊàêÂäü„Åó„Åæ„Åó„Åü', {
        title: importedData.title,
        nodeCount: countNodes(importedData.rootNode),
        warnings,
        rootNode: importedData.rootNode,
        rootNodeChildren: importedData.rootNode?.children?.length || 0
      });

      // „Ç§„É≥„Éù„Éº„Éà„Åï„Çå„Åü„Éá„Éº„Çø„ÇíÁõ¥Êé•„Çπ„Éà„Ç¢„Å´Ë®≠ÂÆö
      logger.info('„Çπ„Éà„Ç¢„Å´„Éá„Éº„Çø„ÇíË®≠ÂÆö‰∏≠...', { 
        hasData: !!importedData, 
        hasRootNode: !!importedData?.rootNode,
        rootNodeText: importedData?.rootNode?.text 
      });
      store.setData(importedData);

      // „Éû„ÉÉ„Éó„Çí„Éû„ÉÉ„Éó„É™„Çπ„Éà„Å´ËøΩÂä†ÔºàÊ∞∏Á∂öÂåñÔºâ
      logger.info('„Éû„ÉÉ„Éó„É™„Çπ„Éà„Å´ËøΩÂä†‰∏≠...', { mapId: importedData.id, title: importedData.title });
      if (typeof addImportedMapToList === 'function') {
        await addImportedMapToList(importedData);
        logger.info('‚úÖ „Éû„ÉÉ„Éó„É™„Çπ„Éà„Å´ËøΩÂä†ÂÆå‰∫Ü');
      } else {
        logger.warn('‚ö†Ô∏è addImportedMapToListÈñ¢Êï∞„ÅåÂà©Áî®„Åß„Åç„Åæ„Åõ„Çì');
      }
      
      // Ë®≠ÂÆöÂæå„ÅÆÁ¢∫Ë™ç
      const currentData = store.data;
      logger.info('„Çπ„Éà„Ç¢Ë®≠ÂÆöÂæå„ÅÆÁ¢∫Ë™ç', {
        currentTitle: currentData?.title,
        currentRootText: currentData?.rootNode?.text,
        currentChildrenCount: currentData?.rootNode?.children?.length || 0
      });

      // „Ç§„É≥„Éù„Éº„ÉàÂæå„Å´Ëá™ÂãïÊï¥Âàó„ÇíÈÅ©Áî®
      logger.info('„Ç§„É≥„Éù„Éº„ÉàÂæå„ÅÆËá™ÂãïÊï¥Âàó„ÇíÈÅ©Áî®‰∏≠...');
      if (typeof applyAutoLayout === 'function') {
        applyAutoLayout();
        logger.info('‚úÖ Ëá™ÂãïÊï¥Âàó„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„Åü');
      } else {
        logger.warn('‚ö†Ô∏è applyAutoLayoutÈñ¢Êï∞„ÅåÂà©Áî®„Åß„Åç„Åæ„Åõ„Çì');
      }

      // ÊàêÂäüÈÄöÁü•
      showNotification('success', `„Äå${importedData.title}„Äç„Çí„Ç§„É≥„Éù„Éº„Éà„Åó„Åæ„Åó„Åü`);
      
      // Ë≠¶Âëä„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØË°®Á§∫
      if (warnings && warnings.length > 0) {
        warnings.forEach(warning => {
          showNotification('warning', warning);
        });
      }
    } catch (error) {
      logger.error('„Ç§„É≥„Éù„Éº„ÉàÂæå„ÅÆÂá¶ÁêÜ„Åß„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü:', error);
      handleError(error as Error, '„Ç§„É≥„Éù„Éº„ÉàÂá¶ÁêÜ', '„Éá„Éº„Çø‰ΩúÊàê');
    }
  };

  // „Éé„Éº„ÉâÊï∞„ÇíÊï∞„Åà„ÇãË£úÂä©Èñ¢Êï∞
  const countNodes = (node: MindMapNode): number => {
    let count = 1; // ÁèæÂú®„ÅÆ„Éé„Éº„Éâ
    if (node.children) {
      count += node.children.reduce((sum, child) => sum + countNodes(child), 0);
    }
    return count;
  };

  // Link-related handlers
  const handleAddLink = (nodeId: string) => {
    console.log('üìù handleAddLink called:', nodeId);
    setEditingLink(null);
    setLinkModalNodeId(nodeId);
    setShowLinkModal(true);
  };

  const handleEditLink = (link: NodeLink, nodeId: string) => {
    console.log('üî• handleEditLink called:', { link, nodeId });
    console.trace('Call stack:');
    setEditingLink(link);
    setLinkModalNodeId(nodeId);
    setShowLinkModal(true);
  };


  const handleSaveLink = async (linkData: Partial<NodeLink>) => {
    if (!linkModalNodeId) return;

    try {
      if (editingLink) {
        // Update existing link
        store.updateNodeLink(linkModalNodeId, editingLink.id, linkData);
        showNotification('success', '„É™„É≥„ÇØ„ÇíÊõ¥Êñ∞„Åó„Åæ„Åó„Åü');
      } else {
        // Add new link
        store.addNodeLink(linkModalNodeId, linkData);
        showNotification('success', '„É™„É≥„ÇØ„ÇíËøΩÂä†„Åó„Åæ„Åó„Åü');
      }
    } catch (error) {
      logger.error('Link save error:', error);
      handleError(error as Error, '„É™„É≥„ÇØÊìç‰Ωú', '„É™„É≥„ÇØ„ÅÆ‰øùÂ≠ò');
    }
  };

  const handleDeleteLink = async (linkId: string) => {
    if (!linkModalNodeId) return;

    try {
      store.deleteNodeLink(linkModalNodeId, linkId);
      showNotification('success', '„É™„É≥„ÇØ„ÇíÂâäÈô§„Åó„Åæ„Åó„Åü');
    } catch (error) {
      logger.error('Link delete error:', error);
      handleError(error as Error, '„É™„É≥„ÇØÊìç‰Ωú', '„É™„É≥„ÇØ„ÅÆÂâäÈô§');
    }
  };

  // „Éé„Éº„Éâ„ÇíÁîªÈù¢‰∏≠Â§Æ„Å´ÁßªÂãï„Åô„ÇãÈñ¢Êï∞
  const centerNodeInView = useCallback((nodeId: string, animate = true) => {
    if (!data) return;
    
    const targetNode = findNodeById(data.rootNode, nodeId);
    if (!targetNode) return;

    // „Éì„É•„Éº„Éù„Éº„Éà„ÅÆ‰∏≠ÂøÉÂ∫ßÊ®ô„ÇíË®àÁÆó
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    const viewportCenterX = viewportWidth / 2;
    const viewportCenterY = viewportHeight / 2;

    // „Éé„Éº„Éâ„ÅÆÁèæÂú®„ÅÆÂ∫ßÊ®ô
    const nodeX = targetNode.x || 0;
    const nodeY = targetNode.y || 0;

    // ÁèæÂú®„ÅÆ„Ç∫„Éº„É†Áéá„ÇíÂèñÂæóÔºàSVG„Åß„ÅØ1.5ÂÄç„Åï„Çå„Å¶„ÅÑ„ÇãÔºâ
    const currentZoom = ui.zoom * 1.5;

    // SVG„ÅÆ transform="scale(s) translate(tx, ty)" „ÅÆÂ†¥Âêà„ÄÅ
    // ÊúÄÁµÇÂ∫ßÊ®ô„ÅØ s * (x + tx) „Å®„Å™„Çã„Åü„ÇÅ„ÄÅ‰∏≠Â§Æ„Å´ÈÖçÁΩÆ„Åô„Çã„Å´„ÅØÔºö
    // centerX = currentZoom * (nodeX + panX) ‚Üí panX = centerX/currentZoom - nodeX
    const newPanX = viewportCenterX / currentZoom - nodeX;
    const newPanY = viewportCenterY / currentZoom - nodeY;

    if (animate) {
      // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥‰ªò„Åç„Åß„Éë„É≥„ÇíÊõ¥Êñ∞
      const currentPan = ui.pan;
      // const duration = 300; // 300ms (Êú™‰ΩøÁî®)
      const steps = 20;
      
      const deltaX = (newPanX - currentPan.x) / steps;
      const deltaY = (newPanY - currentPan.y) / steps;
      
      let step = 0;
      const animateStep = () => {
        if (step < steps) {
          step++;
          const currentX = currentPan.x + (deltaX * step);
          const currentY = currentPan.y + (deltaY * step);
          setPan({ x: currentX, y: currentY });
          
          requestAnimationFrame(animateStep);
        }
      };
      
      requestAnimationFrame(animateStep);
    } else {
      // Âç≥Â∫ß„Å´„Éë„É≥„ÇíÊõ¥Êñ∞
      setPan({ x: newPanX, y: newPanY });
    }
  }, [data, ui.zoom, ui.pan, setPan]);

  // „É´„Éº„Éà„Éé„Éº„Éâ„Çí‰∏≠Â§Æ„Å´Ë°®Á§∫„Åô„Çã„Éè„É≥„Éâ„É©„Éº
  const handleCenterRootNode = useCallback(() => {
    if (data?.rootNode) {
      centerNodeInView(data.rootNode.id, true);
    }
  }, [data?.rootNode, centerNodeInView]);

  const handleLinkNavigate = async (link: NodeLink) => {
    try {
      // If targetMapId is specified and different from current map
      if (link.targetMapId && link.targetMapId !== currentMapId) {
        // Navigate to different map
        try {
          await selectMapById(link.targetMapId);
          showNotification('success', `„Éû„ÉÉ„Éó "${link.targetMapId}" „Å´ÁßªÂãï„Åó„Åæ„Åó„Åü`);
          
          // If targetNodeId is specified, select that node after map loads
          if (link.targetNodeId) {
            setTimeout(() => {
              selectNode(link.targetNodeId!);
              // „Éû„ÉÉ„Éó„É≠„Éº„ÉâÂæå„Å´„Éé„Éº„Éâ„Çí‰∏≠Â§Æ„Å´ÁßªÂãï
              setTimeout(() => {
                centerNodeInView(link.targetNodeId!);
              }, 100);
            }, 500); // Wait for map to load
          }
        } catch (error) {
          showNotification('error', `„Éû„ÉÉ„Éó "${link.targetMapId}" „ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì`);
          return;
        }
      } else if (link.targetNodeId) {
        // Navigate to node in current map
        if (data) {
          const targetNode = findNodeById(data.rootNode, link.targetNodeId);
          if (targetNode) {
            selectNode(link.targetNodeId);
            // „Éé„Éº„Éâ„ÇíÁîªÈù¢‰∏≠Â§Æ„Å´ÁßªÂãï
            setTimeout(() => {
              if (link.targetNodeId) {
                centerNodeInView(link.targetNodeId);
              }
            }, 50); // DOMÊõ¥Êñ∞„ÇíÂæÖ„Å§
            showNotification('success', `„Éé„Éº„Éâ "${targetNode.text}" „Å´ÁßªÂãï„Åó„Åæ„Åó„Åü`);
          } else {
            showNotification('error', `„Éé„Éº„Éâ "${link.targetNodeId}" „ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì`);
          }
        }
      } else {
        showNotification('info', '„É™„É≥„ÇØÂÖà„ÅåÊåáÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì');
      }
    } catch (error) {
      logger.error('Link navigation error:', error);
      handleError(error as Error, '„É™„É≥„ÇØÊìç‰Ωú', '„É™„É≥„ÇØÂÖà„Å∏„ÅÆÁßªÂãï');
    }
  };

  const handleShowLinkActionMenu = (link: NodeLink, position: { x: number; y: number }) => {
    setLinkActionMenuData({ link, position });
    setShowLinkActionMenu(true);
  };

  const handleCloseLinkActionMenu = () => {
    setShowLinkActionMenu(false);
    setLinkActionMenuData(null);
  };

  const handleOutlineSave = async (updatedData: MindMapData) => {
    try {
      store.setData(updatedData);
      
      if (typeof applyAutoLayout === 'function') {
        applyAutoLayout();
      }
      
      showNotification('success', '„Ç¢„Ç¶„Éà„É©„Ç§„É≥„Çí„Éû„Ç§„É≥„Éâ„Éû„ÉÉ„Éó„Å´ÂèçÊò†„Åó„Åæ„Åó„Åü');
      store.setShowOutlineEditor(false);
    } catch (error) {
      logger.error('Outline save failed:', error);
      showNotification('error', '„Ç¢„Ç¶„Éà„É©„Ç§„É≥„ÅÆ‰øùÂ≠ò„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
      handleError(error as Error, '„Ç¢„Ç¶„Éà„É©„Ç§„É≥‰øùÂ≠ò', '„Éá„Éº„ÇøÂ§âÊèõ');
    }
  };


  // Show loading while auth is initializing in cloud mode
  if (isCloudMode && auth && !auth.isReady) {
    return (
      <div className="flex items-center justify-center h-screen bg-gray-50">
        <div className="text-center">
          <div className="w-8 h-8 border-2 border-blue-600 border-t-transparent rounded-full animate-spin mx-auto mb-4"></div>
          <p className="text-gray-600">Ë™çË®º„Ç∑„Çπ„ÉÜ„É†„ÇíÂàùÊúüÂåñ‰∏≠...</p>
        </div>
      </div>
    );
  }

  if (!data) {
    return (
      <div className="flex items-center justify-center h-screen bg-gray-50">
        <div className="text-center">
          <div className="w-8 h-8 border-2 border-blue-600 border-t-transparent rounded-full animate-spin mx-auto mb-4"></div>
          <p className="text-gray-600">„Éá„Éº„Çø„ÇíË™≠„ÅøËæº„Åø‰∏≠...</p>
        </div>
      </div>
    );
  }

  return (
    <div 
      className="mindmap-app"
      tabIndex={0}
      onFocus={() => {
        // VimiumÂØæÁ≠ñ: „Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„Å´„Éï„Ç©„Éº„Ç´„ÇπÊôÇ„Å´„Éï„Ç©„Éº„Ç´„ÇπÁä∂ÊÖã„ÇíÁ∂≠ÊåÅ
      }}
      style={{ outline: 'none' }}
    >
      <ActivityBar
        activeView={activeView}
        onViewChange={setActiveView}
        onShowKeyboardHelper={() => setShowKeyboardHelper(!showKeyboardHelper)}
      />
      
      <PrimarySidebar
        activeView={activeView}
        isVisible={activeView !== null}
        mindMaps={allMindMaps}
        currentMapId={currentMapId}
        onSelectMap={(mapId) => { selectMapById(mapId); }}
        onCreateMap={createAndSelectMap}
        onDeleteMap={deleteMap}
        onRenameMap={(mapId, title) => updateMapMetadata(mapId, { title })}
        onChangeCategory={(mapId, category) => updateMapMetadata(mapId, { category })}
        onChangeCategoryBulk={updateMultipleMapCategories}
        availableCategories={['‰ªï‰∫ã', '„Éó„É©„Ç§„Éô„Éº„Éà', 'Â≠¶Áøí', 'Êú™ÂàÜÈ°û']}
        storageMode={storageMode}
        onStorageModeChange={onModeChange}
        onShowKeyboardHelper={() => setShowKeyboardHelper(!showKeyboardHelper)}
        onAutoLayout={() => {
          logger.info('Manual auto layout triggered');
          if (typeof mindMap.applyAutoLayout === 'function') {
            mindMap.applyAutoLayout();
          } else {
            logger.error('applyAutoLayout function not available');
          }
        }}
        onExport={handleExport}
        onImport={handleImport}
        currentMapData={data}
        onNodeSelect={(nodeId) => {
          selectNode(nodeId);
          centerNodeInView(nodeId);
        }}
        onMapSwitch={(mapId) => {
          selectMapById(mapId);
        }}
      />

      <div className={`mindmap-main-content ${activeView ? 'with-sidebar' : ''}`}>
        <MindMapHeader 
          data={data}
          onTitleChange={handleTitleChange}
          onUndo={undo}
          onRedo={redo}
          canUndo={canUndo}
          canRedo={canRedo}
          zoom={ui.zoom}
          onZoomReset={() => setZoom(1.0)}
          onAutoLayout={() => {
            logger.info('Manual auto layout triggered');
            if (typeof mindMap.applyAutoLayout === 'function') {
              mindMap.applyAutoLayout();
            } else {
              logger.error('applyAutoLayout function not available');
            }
          }}
          storageMode={storageMode}
          onStorageModeChange={onModeChange}
          onToggleNotesPanel={() => store.toggleNotesPanel()}
          showNotesPanel={ui.showNotesPanel}
          onToggleViewMode={() => store.toggleViewMode()}
          viewMode={ui.viewMode}
          onCenterRootNode={handleCenterRootNode}
        />
        
        <div className="workspace-container">
          {ui.viewMode === 'mindmap' ? (
            <MindMapWorkspace 
              data={data}
              selectedNodeId={selectedNodeId}
              editingNodeId={editingNodeId}
              editText={editText}
              setEditText={setEditText}
              onSelectNode={(nodeId) => {
                selectNode(nodeId);
                // „Éé„Éº„ÉàË°®Á§∫„Éï„É©„Ç∞„ÅåÊúâÂäπ„Å™Â†¥Âêà„ÅÆ„Åø„Éé„Éº„Éà„Éë„Éç„É´„ÇíË°®Á§∫
                // „Éé„Éº„Éà„Éï„É©„Ç∞„ÅåÁÑ°Âäπ„Å™Â†¥Âêà„ÅØ„Éé„Éº„ÉâÈÅ∏Êäû„Åó„Å¶„ÇÇ„Éé„Éº„Éà„Éë„Éç„É´„ÇíË°®Á§∫„Åó„Å™„ÅÑ
              }}
              onStartEdit={startEditing}
              onFinishEdit={finishEditing}
              onMoveNode={moveNode}
              onChangeSiblingOrder={changeSiblingOrder}
              onAddChild={addNode}
              onAddSibling={(nodeId) => store.addSiblingNode(nodeId)}
              onDeleteNode={deleteNode}
              onRightClick={handleRightClick}
              onToggleCollapse={toggleNodeCollapse}
              onFileUpload={(nodeId, files) => {
                if (files.length > 0) {
                  handleFileUpload(nodeId, files[0]);
                }
              }}
              onRemoveFile={handleFileDelete}
              onShowImageModal={showImageModal}
              onShowFileActionMenu={(file, _nodeId, position) => showFileActionMenu(file, position)}
              onShowLinkActionMenu={handleShowLinkActionMenu}
              onAddLink={handleAddLink}
              onUpdateNode={updateNode}
              onAutoLayout={applyAutoLayout}
              availableMaps={allMindMaps.map(map => ({ id: map.id, title: map.title }))}
              currentMapData={data}
              onLinkNavigate={handleLinkNavigate}
              zoom={ui.zoom}
              setZoom={setZoom}
              pan={ui.pan}
              setPan={setPan}
              onToggleAttachmentList={store.toggleAttachmentListForNode}
              onToggleLinkList={store.toggleLinkListForNode}
            />
          ) : (
            <OutlineWorkspace
              data={data}
              onSave={(updatedData) => {
                store.setData(updatedData);
                if (typeof applyAutoLayout === 'function') {
                  applyAutoLayout();
                }
              }}
              hasSidebar={activeView !== null}
            />
          )}
          
          {ui.showNotesPanel && ui.viewMode === 'mindmap' && (
            <NodeNotesPanel
              selectedNode={selectedNodeId ? findNodeById(data?.rootNode, selectedNodeId) : null}
              onUpdateNode={updateNode}
              onClose={() => store.setShowNotesPanel(false)}
            />
          )}
        </div>
      </div>
      
      <MindMapModals 
        ui={ui}
        selectedNodeId={selectedNodeId}
        nodeOperations={{
          findNode: (nodeId: string) => findNodeById(data?.rootNode, nodeId),
          onDeleteNode: deleteNode,
          onUpdateNode: updateNode,
          onCopyNode: () => {},
          onPasteNode: () => {},
          onShowCustomization: () => {},
          onAddChild: (parentId: string, text?: string) => {
            return store.addChildNode(parentId, text || 'New Node');
          }
        }}
        fileOperations={{
          onFileDownload: handleFileDownload,
          onFileRename: () => {},
          onFileDelete: (fileId: string) => {
            // selectedFile„Å®selectedNodeId„Åã„ÇâÈÅ©Âàá„Å™nodeId„ÇíÂèñÂæó„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô
            if (ui.selectedFile && ui.selectedFile.nodeId) {
              handleFileDelete(ui.selectedFile.nodeId, fileId);
            } else if (ui.selectedFile && selectedNodeId) {
              // fallback„Å®„Åó„Å¶selectedNodeId„Çí‰ΩøÁî®
              handleFileDelete(selectedNodeId, fileId);
            }
          },
          onShowImageModal: showImageModal
        }}
        uiOperations={{
          onCloseContextMenu: closeAllPanels,
          onCloseCustomizationPanel: closeAllPanels,
          onCloseImageModal: closeAllPanels,
          onCloseFileActionMenu: closeAllPanels
        }}
      />
      
      {/* Keyboard Shortcut Helper */}
      <KeyboardShortcutHelper
        isVisible={showKeyboardHelper}
        onClose={() => setShowKeyboardHelper(false)}
      />
      
      {/* Vim status bar */}
      <VimStatusBar />
      
      {/* Authentication Modal - Shows when cloud mode requires login */}
      {isCloudMode && authAdapter && (
        <LoginModal 
          isOpen={showLoginModal}
          onClose={() => {
            logger.info('Login modal closed, switching to local mode');
            setShowLoginModal(false);
            // Switch back to local mode when user cancels login
            if (onModeChange) {
              onModeChange('local');
            }
          }}
        />
      )}

      {/* Export Modal */}
      <ExportModal
        isOpen={showExportModal}
        onClose={() => setShowExportModal(false)}
        mindMapData={data}
      />

      {/* Import Modal */}
      <ImportModal
        isOpen={showImportModal}
        onClose={() => setShowImportModal(false)}
        onImportSuccess={handleImportSuccess}
      />

      {/* Node Link Modal */}
      {showLinkModal && linkModalNodeId && (
        <NodeLinkModal
          isOpen={showLinkModal}
          onClose={() => {
            setShowLinkModal(false);
            setEditingLink(null);
            setLinkModalNodeId(null);
          }}
          node={findNodeById(data.rootNode, linkModalNodeId)!}
          link={editingLink}
          onSave={handleSaveLink}
          onDelete={handleDeleteLink}
          availableMaps={allMindMaps.map(map => ({ id: map.id, title: map.title }))}
          currentMapData={data}
          onLoadMapData={loadMapData}
        />
      )}

      {/* Link Action Menu */}
      {showLinkActionMenu && linkActionMenuData && (
        <LinkActionMenu
          isOpen={showLinkActionMenu}
          position={linkActionMenuData.position}
          link={linkActionMenuData.link}
          onClose={handleCloseLinkActionMenu}
          onNavigate={handleLinkNavigate}
          onEdit={(link) => {
            handleCloseLinkActionMenu();
            handleEditLink(link, linkModalNodeId!);
          }}
          onDelete={(linkId) => {
            handleCloseLinkActionMenu();
            handleDeleteLink(linkId);
          }}
          availableMaps={allMindMaps.map(map => ({ id: map.id, title: map.title }))}
          currentMapData={data}
        />
      )}
      
      {/* Outline Editor */}
      {ui.showOutlineEditor && (
        <OutlineWorkspace
          data={data}
          onSave={handleOutlineSave}
          onClose={() => store.setShowOutlineEditor(false)}
          hasSidebar={activeView !== null}
        />
      )}

      {/* Context Menu */}
      {contextMenu.visible && contextMenu.nodeId && (
        <ContextMenu
          visible={contextMenu.visible}
          position={contextMenu.position}
          selectedNode={data?.rootNode ? findNodeById(data.rootNode, contextMenu.nodeId) : null}
          onDelete={deleteNode}
          onCustomize={(node) => {
            selectNode(node.id);
            store.showCustomization({ x: contextMenu.position.x, y: contextMenu.position.y });
            handleContextMenuClose();
          }}
          onFileUpload={(nodeId, files) => {
            if (files.length > 0) {
              handleFileUpload(nodeId, files[0]);
            }
          }}
          onAddLink={(nodeId) => {
            setLinkModalNodeId(nodeId);
            setShowLinkModal(true);
          }}
          onCopy={(node) => {
            // „Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà„Ç≠„Éº„Å®Âêå„ÅòcopyNodeÈñ¢Êï∞„Çí‰ΩøÁî®
            const copyNode = (nodeId: string) => {
              const nodeToFind = data?.rootNode ? findNodeById(data.rootNode, nodeId) : null;
              if (nodeToFind) {
                // ÂÜÖÈÉ®„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Å´‰øùÂ≠ò
                store.setClipboard(nodeToFind);
                
                // „Ç∑„Çπ„ÉÜ„É†„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Å´„Éû„Éº„ÇØ„ÉÄ„Ç¶„É≥ÂΩ¢Âºè„Åß‰øùÂ≠ò
                const convertNodeToMarkdown = (node: MindMapNode, level: number = 0): string => {
                  const prefix = '#'.repeat(Math.min(level + 1, 6)) + ' ';
                  let markdown = `${prefix}${node.text}\n`;
                  
                  // „Éé„Éº„Éà„Åå„ÅÇ„Çå„Å∞ËøΩÂä†
                  if (node.note && node.note.trim()) {
                    markdown += `${node.note}\n`;
                  }
                  
                  // Â≠ê„Éé„Éº„Éâ„ÇíÂÜçÂ∏∞ÁöÑ„Å´Âá¶ÁêÜ
                  if (node.children && node.children.length > 0) {
                    node.children.forEach(child => {
                      markdown += convertNodeToMarkdown(child, level + 1);
                    });
                  }
                  
                  return markdown;
                };
                
                const markdownText = convertNodeToMarkdown(nodeToFind);
                
                // „Ç∑„Çπ„ÉÜ„É†„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Å´Êõ∏„ÅçËæº„Åø
                if (navigator.clipboard && navigator.clipboard.writeText) {
                  navigator.clipboard.writeText(markdownText).catch((error) => {
                    console.warn('„Ç∑„Çπ„ÉÜ„É†„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Å∏„ÅÆÊõ∏„ÅçËæº„Åø„Å´Â§±Êïó:', error);
                  });
                }
                
                showNotification('success', `„Äå${nodeToFind.text}„Äç„Çí„Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü`);
              }
            };
            
            copyNode(node.id);
            handleContextMenuClose();
          }}
          onPaste={async (parentId) => {
            // „Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà„Ç≠„Éº„Å®Âêå„ÅòpasteNodeÈñ¢Êï∞„Çí‰ΩøÁî®
            const pasteNode = async (parentId: string) => {
              // „Åæ„Åö„Ç∑„Çπ„ÉÜ„É†„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Åã„ÇâMindMeister„ÅÆ„Éû„Éº„ÇØ„ÉÄ„Ç¶„É≥„ÇíÁ¢∫Ë™ç
              try {
                if (navigator.clipboard && navigator.clipboard.readText) {
                  const clipboardText = await navigator.clipboard.readText();
                  
                  // MindMeister„ÅÆ„Éû„Éº„ÇØ„ÉÄ„Ç¶„É≥ÂΩ¢Âºè„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                  const { isMindMeisterFormat, parseMindMeisterMarkdown } = await import('../../../../shared/utils/mindMeisterParser');
                  
                  if (clipboardText && isMindMeisterFormat(clipboardText)) {
                    const parsedNode = parseMindMeisterMarkdown(clipboardText);
                    
                    if (parsedNode) {
                      // „Éë„Éº„Çπ„Åï„Çå„Åü„Éé„Éº„ÉâÊßãÈÄ†„ÇíË≤º„Çä‰ªò„Åë
                      const pasteNodeRecursively = (nodeToAdd: MindMapNode, parentId: string): string | undefined => {
                        const newNodeId = store.addChildNode(parentId, nodeToAdd.text);
                        
                        if (newNodeId) {
                          updateNode(newNodeId, {
                            fontSize: nodeToAdd.fontSize,
                            fontWeight: nodeToAdd.fontWeight,
                            color: nodeToAdd.color,
                            collapsed: false,
                            attachments: nodeToAdd.attachments || [],
                            note: nodeToAdd.note
                          });
                          
                          if (nodeToAdd.children && nodeToAdd.children.length > 0) {
                            nodeToAdd.children.forEach(child => {
                              pasteNodeRecursively(child, newNodeId);
                            });
                          }
                        }
                        
                        return newNodeId;
                      };
                      
                      const newNodeId = pasteNodeRecursively(parsedNode, parentId);
                      if (newNodeId) {
                        showNotification('success', `„Äå${parsedNode.text}„Äç„ÇíMindMeister„Åã„ÇâË≤º„Çä‰ªò„Åë„Åæ„Åó„Åü`);
                        selectNode(newNodeId);
                        return;
                      }
                    }
                  }
                }
              } catch (error) {
                console.warn('„Ç∑„Çπ„ÉÜ„É†„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Åã„Çâ„ÅÆË™≠„ÅøÂèñ„Çä„Å´Â§±Êïó:', error);
              }
              
              // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: ÂÜÖÈÉ®„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Åã„ÇâË≤º„Çä‰ªò„Åë
              const clipboardNode = ui.clipboard;
              if (!clipboardNode) {
                showNotification('warning', '„Ç≥„Éî„Éº„Åï„Çå„Åü„Éé„Éº„Éâ„Åå„ÅÇ„Çä„Åæ„Åõ„Çì');
                return;
              }
              
              const pasteNodeRecursively = (nodeToAdd: MindMapNode, parentId: string): string | undefined => {
                const newNodeId = store.addChildNode(parentId, nodeToAdd.text);
                
                if (newNodeId) {
                  updateNode(newNodeId, {
                    fontSize: nodeToAdd.fontSize,
                    fontWeight: nodeToAdd.fontWeight,
                    color: nodeToAdd.color,
                    collapsed: false,
                    attachments: nodeToAdd.attachments || []
                  });
                  
                  if (nodeToAdd.children && nodeToAdd.children.length > 0) {
                    nodeToAdd.children.forEach(child => {
                      pasteNodeRecursively(child, newNodeId);
                    });
                  }
                }
                
                return newNodeId;
              };
              
              const newNodeId = pasteNodeRecursively(clipboardNode, parentId);
              if (newNodeId) {
                showNotification('success', `„Äå${clipboardNode.text}„Äç„ÇíË≤º„Çä‰ªò„Åë„Åæ„Åó„Åü`);
                selectNode(newNodeId);
              }
            };
            
            await pasteNode(parentId);
            handleContextMenuClose();
          }}
          onAIGenerate={ai.aiSettings.enabled ? handleAIGenerate : undefined}
          onClose={handleContextMenuClose}
        />
      )}
    </div>
  );
};

const MindMapApp: React.FC<MindMapAppProps> = (props) => {
  return (
    <MindMapProviders>
      <MindMapAppContent {...props} />
    </MindMapProviders>
  );
};

export default MindMapApp;